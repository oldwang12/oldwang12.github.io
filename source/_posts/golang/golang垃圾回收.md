---
layout: golang
title: golang垃圾回收
date: 2023-08-16 17:17:32
tags: golang
categories: golang
---

{% note primary %}
golang是通过 {% label primary @三色标记法 %} 来进行垃圾回收。
{% endnote %}

<!-- more -->

## 1. 标记过程

![image](/img/golang垃圾回收.png)

- 初始状态下所有对象都是白色的。
- 从根节点开始遍历所有对象，把遍历到的对象变成灰色对象
- 遍历灰色对象，将灰色对象引用的对象也变成灰色对象，然后将遍历过的灰色对象变成黑色对象。
- 循环步骤3，直到灰色对象全部变黑色。
- 通过写屏障(write-barrier)检测对象有变化，重复以上操作
- 回收所有白色对象（垃圾）。

## 2. 根对象是什么？

根对象在垃圾回收的术语中又叫做根集合，它是垃圾回收器在标记过程时最先检查的对象，包括：

- 全局变量：程序在编译期就能确定的那些存在于程序整个生命周期的变量。
- 执行栈：每个 goroutine 都包含自己的执行栈，这些执行栈上包含栈上的变量及指向分配的堆内存区块的指针。
- 寄存器：寄存器的值可能表示一个指针，参与计算的这些指针可能指向某些赋值器分配的堆内存区块。

## 3. STW（Stop The World）

- 为了避免在 GC 的过程中，对象之间的引用关系发生新的变更，使得GC的结果发生错误（如GC过程中新增了一个引用，但是由于未扫描到该引用导致将被引用的对象清除了），停止所有正在运行的协程。
- STW对性能有一些影响，Golang目前已经可以做到1ms以下的STW。

## 4. 写屏障(Write Barrier)

为了避免GC的过程中新修改的引用关系到GC的结果发生错误，我们需要进行STW。但是STW会影响程序的性能，所以我们要{% label danger @通过写屏障技术尽可能地缩短STW的时间。 %}

### 4.1. 4.1 写屏障的原理

造成引用对象丢失的条件:

- 一个黑色A新增了指向白色C的引用，
- 白色C没有其他灰色的引用(除A之外)。

以上两个条件需要同时满足：满足条件1时说明A已扫描完毕，A指向C的引用无法再被扫描到；满足条件2时说明C无其他灰色的引用了，即扫描结束后会被忽略 。

{% label danger @写屏障破坏两个条件其一即可 %}
#### 4.1.1. 4.2 如何破坏？

- **Dijistra写屏障**

满足强三色不变性：黑色节点不允许引用白色节点，当黑色节点新增了白色节点的引用时，将对应的白色节点改为灰色

- **Yuasa写屏障**
   
满足弱三色不变性：黑色节点允许引用白色节点，但是该白色节点有其他灰色节点间接的引用（确保不会被遗漏），当白色节点被删除了一个引用时，悲观地认为它一定会被一个黑色节点新增引用，所以将它置为灰色

## 5. GC 触发时机

**内存分配量达到阈值触发GC**

每次内存分配时都会检查当前内存分配量是否已达到阈值，如果达到阈值立即启动GC，

{% label primary @阈值 = 上次GC内存分配量 × 内存增长率 %}

**定期触发GC**

默认情况下，最长2分钟触发一次GC，这个时间间隔由 runtime.forcegcperiod变量声明

**主动触发**

程序代码中可以调用 runtime.GC() 来触发GC，主要用于GC的性能测试和统计。

